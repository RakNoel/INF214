% % % % % % % % % % % % % % % % %
%	INF214
%	Assignement 1
%	Oskar L. F. Leriv√•g
%

\documentclass[a4paper, 12pt, pstricks]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{pgf,tikz}
\usepackage{mathrsfs}
\usepackage{listings}
\usepackage{polynom}
\usepackage{pgfplots}
\usetikzlibrary{arrows}
\usepackage{amssymb}
\usepackage{url}

%Images
\usepackage{graphicx}
\usepackage{float}

%Margins
\usepackage{geometry}
\geometry{a4paper, margin=2cm}

\newcommand{\mysection}[1]{\section*{#1} \addcontentsline{toc}{section}{#1}}
\newcommand{\mysubsection}[1]{\subsection*{#1} \addcontentsline{toc}{subsection}{#1}}
\newcommand{\mysubsubsection}[1]{\subsubsection*{#1} \addcontentsline{toc}{subsubsection}{#1}}



\begin{document}

% % % % % % % % % % % % % % % % %
%
%	FORDISE!
%
\input{./uib_frontpage.tex}

\newpage

\mysection{Task 0:}
{
	I did try my very best, and I'm able to imagine it, but I cannot convince myself without the needed evidence.
}

\mysection{Task 1:}
\mysubsection{Enqueue:}
{
	V: Head, Rear, \_size, Rear $\rightarrow$ Next \\
	W: Head, Rear, \_size, Rear $\rightarrow$ Next
}
\\\\
{
	The Enqueue option will perform almost incremental changes to the variables, and  therefore we will see a pattern where it will read from then write to the same 	variables.
}

\mysubsection{Dequeue:}
{
	V: Head, Rear, \_size, Head $\rightarrow$ Next, Head $\rightarrow$ Data \\
	W: Head, Rear, \_size
}
\\\\
{
	The dequeue operation will be rather different. This is a decremental function, but since we're removing data there will be less writing. But since we also want to return the data we will need to read more. Therefore, even if we only change three variables to point elsewhere, we will need to extract and validate some data anyway.
}

\mysubsection{Operator++:}
{
	V: it, it $\rightarrow$ next \\
	W: it
}
\\\\
{
	The Operator++ is rather simple as it is just jumping trough the nodes. So it is reading the current and its next node, while only writing the current node.
}

\mysubsection{Operator$\star$:}
{
	V: it, it $\rightarrow$ data \\
	W:
}
\\\\
{
	Only fetching the data from the node is even simpler, so here we don't even have to write at all.
}

\mysection{Concurrent operations:}
{
	\begin{center}
 		\begin{tabular}{ l | c c c c }
   			\/ & Enqueue & Dequeue & Operator++ & Operator$\star$ \\ \hline
   			Enqueue & No & No & Yes & Yes \\
   			Dequeue & No & No & Yes & Yes \\
   			Operator++ & Yes & Yes & No & No \\
   			Operator$\star$ & Yes & Yes & No & Yes
   	    \end{tabular}
    \end{center}
}

\newpage

\mysection{Task 2:}
{
	I did encounter a lot of problems with this, but in the end it turned out to really be solvable.
}

\mysection{Task 3:}
{
	To limit the code and changes needed I chose to keep the variables the same, and keep them atomic with the
A$<>$ notation. Since a semaphore is not directly implemented in C++, One could potentially use the mutex-lock. 
Which again could probably just be replaced by using the "enter/exit \_critical" since that's what it looks like 
A-Lang does, although since not used in lectures was not intended to be used. But to do this the right way using semaphores we will implement the A-Lang semaphores.
}

\end{document}
